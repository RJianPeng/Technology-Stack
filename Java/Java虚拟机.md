* [一、Java内存模型](#一java内存模型)
* [二、Java指令重排序](#二java指令重排序)
* [三、运行时数据区域](#三运行时数据区域)
* [四、垃圾回收](#四垃圾回收)


# 一、Java内存模型
Java内存模型（JMM)：

为了缩小CPU运算速度和主存读写速度的差异，每个工作线程都会有自己的工作内存。所有变量储存在主内存中，每条线程还有自己的工作内存，里面保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都是在工作内存中完成的，完成之后再将新的变量的值写回主内存，并且Java内存模型还决定了一个线程写入主内存的共享变量什么时候对其他线程是可见的。

另外JMM也是用来屏蔽各种硬件和操作系统的内存访问差异，以实现让java程序在各个平台下都能达到一致的内存访问效果。是Java多线程共享内存的抽象模型。多个线程之间通过共享内存实现线程通信。

内存模型如图（图片来源：https://www.jianshu.com/p/15106e9c4bf3）：
<div align="center"> <img src="https://upload-images.jianshu.io/upload_images/4899162-66736384361f6b8b.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp"/></div><br>

### java内存模型关于主内存和工作内存的交互协议，定义了8种操作来完成：
* 1.lock：作用于主内存的变量，他把一个变量标识为一条线程独占的状态
* 2.unlock：作用于主内存的变量，他把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
* 3.read：作用于主内存的变量，他把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
* 4.load：作用于工作内存的变量，他把read操作从主内存中得到的变量值放入工作内存的变量副本中
* 5.use：作用于工作内存的变量，他把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作
* 6.assign（赋值）：作用于工作内存的变量，他把一个从执行引擎接受到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
* 7.store：作用于工作内存的变量，他把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用
* 8.write：作用于主内存的变量，他把store操作从工作内存中得到的变量的值放入主内存的变量中。

# 二、Java指令重排序
Java在实际执行程序的时候，为了提升性能，编译器和处理器经常会对Java指令进行重排序。

一般重排序分为三种：
* 1.编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
* 2.指令级并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应的机器指令的执行顺序。
* 3.内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储的操作看上去可能是在乱序执行的。

以上三种重排序方式，其中第一种是编译器重排序，第二、三种是处理器重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序。但是这些重排序的优化依然可能造成线程安全问题，比如DCL问题。
## DCL问题
DCL:double-check-locking,双重检查锁。这个双重检查锁最常见的应用就是在单例模式中：
```
public class Singleton {
    private static Singleton singleton;

    private Singleton() {
    }

    public static Singleton GetInstance() {
        //第一重check
        if (singleton == null) {
            synchronized (Singleton.class) {
                //第二重check
                if (singleton == null) {
                    singleton = new Singleton();   // 1
                }
            }
        }
        return singleton;  // 2
    }
}
```
而在代码执行过程中
```
singleton = new Singleton();   // 1
```
这一步实例化代码其实是分三步的：1.1申请对象空降。  1.2调用对象的构造方法初始化对象。 1.3将singleton指向对象。 而在这个过程中，Java底层会为了性能，对1.1、1.2、1.3、2这四步指令进行重排序，也就是说可能4会在1.2之前执行，那此时返回对还是为null。这就是DCL问题。

解决方式：
* 1.用volatile修饰singleton，阻止指令的重排序。
* 2.用饿汉式实现单例，不管会不会使用到该类，一开始就实例化该类的单例对象。

## happens-before规则
重排序底层的规则非常的复杂，因此JMM为程序员在上层提供了六条规则，这样我们就可以根据规则去推论跨线程的内存可见性问题，而不用再去理解底层重排序的规则。

happens-before规则定义：
* 1.如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
* 2.两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。只要保证重排序之后执行的结果与按happens-before关系来执行的结果一致即可。

#### happens-before规则中所指的操作可以分别在多个线程中。

具体规则：
* 1.程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
* 2.监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
* 3.volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
* 4.传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
* 5.start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
* 6.join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。
* 7.程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。
* 8.对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。

个人理解：这些规则并不能强制的在多线程的场景下完美执行。比如volatile变量规则，如果能完美执行，应该不会出现多个线程对共享变量累加与预期不符的问题。


# 三、运行时数据区域
## 程序计数器
较小的内存空间，当前线程所执行的字节码的行号指示器。每个线程都有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储在线程私有内存中。

## 虚拟机栈
线程私有。
生命周期与线程相同。
每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。方法的调用和执行对应这个栈帧的入栈和出栈。

该内存区域两种常见异常：
StackOverflowError:请求的栈的深度大于虚拟机允许的深度时就会抛出该异常
OutOfMemoryError:java虚拟机可以动态扩展的 情况下，如果扩展时无法申请到足够的内存，就会抛出该异常

## 本地方法栈
线程私有。与虚拟机栈作用相似，区别：虚拟机栈为执行java方法（字节码）服务，而本地方法栈为Native方法服务。也会出现以上两种异常。
* HotSpot中不区分本地方法栈和虚拟机栈。

## 堆
内存最大区域。被所有线程共享，虚拟机启动时创建。唯一的目的就是存放对象实例。 
java虚拟机规范上说所有的对象实例和数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，所有对象都分配在堆上也渐渐不是那么绝对了。
是垃圾收集器管理的主要区域。
垃圾收集基本采用分代收集算法，所以堆主要分新生代和老生代。
这部分内存空间可以物理不连续但是要逻辑连续。
动态扩展的情况下，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError的异常。

### 对象的访问定位
通过虚拟机栈上的引用类型来操作堆上的具体对象，目前主流的访问方式有直接指针和使用句柄两种方式（图片来源《深入理解Java虚拟机》）：
* 1.句柄访问：
![句柄访问](https://github.com/RJianPeng/Technology-Stack/blob/master/Java/photo/%E5%8F%A5%E6%9F%84.png)
优势：对象移动的时候只用改变实例数据指针，reference本身不改变

* 2.直接指针：
![直接指针](https://github.com/RJianPeng/Technology-Stack/blob/master/Java/photo/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png)
优势：速度快，Sun HotSpot用的这种

### 对象的内存布局
对象的内存主要分为三块区域：
* 1.对象头：
* ①一部分用于存储对象自身的运行时数据
* ②另一部分是类型指针，即用来指向类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例（查找对象的元数据信息不一定要经过对象本身，这种结构对于对象的访问是采用的直接指针访问对象的方式，上面有讲）
* ③如果是数组，还有一块数据用于记录数组的长度，这个部分还有监视器锁（monitor）的信息

* 2.实例数据部分：
* 存储在程序代码中定义的各种类型的字段内容，这部分的存储内容的存储顺序受虚拟机分配策略和在代码中定义的顺序影响

* 3.对齐填充
* 起到占位符的作用

## 方法区
各个线程的共享区域。
存储被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
java虚拟机规范把方法区描述为堆的一个逻辑部分，也叫非堆，目的应该是与堆区分开来，可以粗略的理解为非堆包含了永久带，永久带又包括了方法区。           
* 这部分的垃圾回收目标主要是针对常量池的回收和对类型的卸载。 

无法满足内存分配需要时，抛出OutOfMemoryError异常。
### 运行时常量池
方法区的一部分。
存放在编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池存放。
每个class文件的常量池被加载之后就将引用存放在这个地方。

### 字符串常量池
和运行时常量池的概念不同。字符串常量池是全局共享的。存放的是String对象的引用，方便复用。
（关于字符串常量池部分的使用可以看https://github.com/RJianPeng/Technology-Stack/blob/master/Java/Java%E5%9F%BA%E7%A1%80.md#string ）

# 四、垃圾回收
## 判断对象是否需要回收的算法
### 引用计数算法
在对象中记录该对象被引用的个数，为0的时候说明这个对象没有存在的意义。
* 主流的java虚拟机都没有选用这个算法来管理内存，因为这个算法很难解决对象之间循环引用的问题。

### 可达性分析算法
主流应用中都是使用这个算法来进行判定。
从一系列的称为“GC Roots"的对象（
* (1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。
* (2). 方法区中的类静态属性引用的对象。
* (3). 方法区中常量引用的对象。
* (4). 本地方法栈中JNI(Native方法)引用的对象。

）作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则此对象是不可用的。

一个对象真正的死亡，至少要经历两次标记过程：如果对象在进行可达性分析时，发现没有与GC Roots相连接的引用链，那么他将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize（）方法或者已经执行过finalize()方法时，都认为这个对象没有必要执行finalize()方法。没有必要执行的直接被回收了，有必要执行的，会被放到一个叫做F-Queue的队列中，并由虚拟机建立的，低优先级的Finalizer线程去执行他。finalize（）是对象逃脱死亡的最后一次机会。

### 引用
上述两种算法都与引用相关，什么是引用，java中的定义是：如果reference类型的数据中存储的数值代表的是另一块内存的起始位置，就称这块内存代表着一个引用。
引用分为四种：强引用，软引用，弱引用，虚引用，四种引用强度依次降低
* 1.强引用：
类似 Object o=new Object();这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。即通过new实例化的对象不会被回收，除非这个对象所在方法结束，此时对这个对象的存在于虚拟机栈中的引用被清空，此时这个对象会被回收。

* 2.软引用：
描述一些还有用但并非必须的对象。对于这些对象，在系统将要发生内存溢出异常之前，将会把这些对象放进回收范围内进行二次回收。通过SoftReference类来实现软引用。
```
Object obj = new Object();
SoftReference<Object> sf  = new SoftReference<Object>(obj);//创建软引用对象
```

* 3.弱引用：
描述非必须对象，强度比软引用弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。
```
Object obj = new Object （）；
WeakReference<Object> wf = new WeakReference<Object>（）；//创建弱引用对象
```
    
* 4.虚引用：
最弱的引用，该引用对对象的生存时间没有影响，只要垃圾回收开始工作，就会被回收
```
Object obj = new Object （）；
PhantomReference<Object> pf = new PhantomReference<Object>(obj)；//创建虚引用对象
```

## 方法区的回收
主要回收：废弃常量和无用的类

废弃常量：没有任何变量引用了这个常量

无用的类：
* 1.该类的所有实例都已经被回收
* 2.加载该类的ClassLoader已经被回收
* 3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法      

## 垃圾回收算法

