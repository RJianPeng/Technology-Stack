* [一、Java内存模型](#一java内存模型)
* [二、Java指令重排序](#二java指令重排序)


# 一、Java内存模型
Java内存模型（JMM)：

为了缩小CPU运算速度和主存读写速度的差异，每个工作线程都会有自己的工作内存。所有变量储存在主内存中，每条线程还有自己的工作内存，里面保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都是在工作内存中完成的，完成之后再将新的变量的值写回主内存，并且Java内存模型还决定了一个线程写入主内存的共享变量什么时候对其他线程是可见的。

另外JMM也是用来屏蔽各种硬件和操作系统的内存访问差异，以实现让java程序在各个平台下都能达到一致的内存访问效果。是Java多线程共享内存的抽象模型。多个线程之间通过共享内存实现线程通信。

内存模型如图（图片来源：https://www.jianshu.com/p/15106e9c4bf3）：
<div align="center"> <img src="https://upload-images.jianshu.io/upload_images/4899162-66736384361f6b8b.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp"/></div><br>

### java内存模型关于主内存和工作内存的交互协议，定义了8种操作来完成：
* 1.lock：作用于主内存的变量，他把一个变量标识为一条线程独占的状态
* 2.unlock：作用于主内存的变量，他把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
* 3.read：作用于主内存的变量，他把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
* 4.load：作用于工作内存的变量，他把read操作从主内存中得到的变量值放入工作内存的变量副本中
* 5.use：作用于工作内存的变量，他把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作
* 6.assign（赋值）：作用于工作内存的变量，他把一个从执行引擎接受到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
* 7.store：作用于工作内存的变量，他把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用
* 8.write：作用于主内存的变量，他把store操作从工作内存中得到的变量的值放入主内存的变量中。

# 二、Java指令重排序
Java在实际执行程序的时候，为了提升性能，编译器和处理器经常会对Java指令进行重排序。

一般重排序分为三种：
* 1.编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
* 2.指令级并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应的机器指令的执行顺序。
* 3.内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储的操作看上去可能是在乱序执行的。

以上三种重排序方式，其中第一种是编译器重排序，第二、三种是处理器重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序。但是这些重排序的优化依然可能造成线程安全问题，比如DCL问题。
## DCL问题
DCL:double-check-locking,双重检查锁。这个双重检查锁最常见的应用就是在单例模式中：
```
public class Singleton {
    private static Singleton singleton;

    private Singleton() {
    }

    public static Singleton GetInstance() {
        //第一重check
        if (singleton == null) {
            synchronized (Singleton.class) {
                //第二重check
                if (singleton == null) {
                    singleton = new Singleton();   // 1
                }
            }
        }
        return singleton;  // 2
    }
}
```
而在代码执行过程中
```
singleton = new Singleton();   // 1
```
这一步实例化代码其实是分三步的：1.1申请对象空降。  1.2调用对象的构造方法初始化对象。 1.3将singleton指向对象。 而在这个过程中，Java底层会为了性能，对1.1、1.2、1.3、2这四步指令进行重排序，也就是说可能4会在1.2之前执行，那此时返回对还是为null。这就是DCL问题。

解决方式：
* 1.用volatile修饰singleton，阻止指令的重排序。
* 2.用饿汉式实现单例，不管会不会使用到该类，一开始就实例化该类的单例对象。

## happens-before规则
重排序底层的规则非常的复杂，因此JMM为程序员在上层提供了六条规则，这样我们就可以根据规则去推论跨线程的内存可见性问题，而不用再去理解底层重排序的规则。

happens-before规则定义：
* 1.如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
* 2.两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。只要保证重排序之后执行的结果与按happens-before关系来执行的结果一致即可。

#### happens-before规则中所指的操作可以分别在多个线程中。

具体规则：
* 1.程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
* 2.监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
* 3.volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
* 4.传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
* 5.start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
* 6.join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。
* 7.程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。
* 8.对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。

个人理解：这些规则并不能强制的在多线程的场景下完美执行。比如volatile变量规则，如果能完美执行，应该不会出现多个线程对共享变量累加与预期不符的问题。
