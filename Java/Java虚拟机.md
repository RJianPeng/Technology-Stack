* [一、Java内存模型](#一java内存模型)
* [二、Java指令重排序](#二java指令重排序)
* [三、运行时数据区域](#三运行时数据区域)
* [四、垃圾回收](#四垃圾回收)
* [五、虚拟机类加载机制](#五虚拟机类加载机制)
* [六、Java内存泄漏](#六java内存泄漏)


# 一、Java内存模型
Java内存模型（JMM)：

为了缩小CPU运算速度和主存读写速度的差异，每个工作线程都会有自己的工作内存。所有变量储存在主内存中，每条线程还有自己的工作内存，里面保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都是在工作内存中完成的，完成之后再将新的变量的值写回主内存，并且Java内存模型还决定了一个线程写入主内存的共享变量什么时候对其他线程是可见的。

另外JMM也是用来屏蔽各种硬件和操作系统的内存访问差异，以实现让java程序在各个平台下都能达到一致的内存访问效果。是Java多线程共享内存的抽象模型。多个线程之间通过共享内存实现线程通信。

内存模型如图（图片来源：https://www.jianshu.com/p/15106e9c4bf3）：
<div align="center"> <img src="https://upload-images.jianshu.io/upload_images/4899162-66736384361f6b8b.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp"/></div><br>

### java内存模型关于主内存和工作内存的交互协议，定义了8种操作来完成：
* 1.lock：作用于主内存的变量，他把一个变量标识为一条线程独占的状态
* 2.unlock：作用于主内存的变量，他把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
* 3.read：作用于主内存的变量，他把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
* 4.load：作用于工作内存的变量，他把read操作从主内存中得到的变量值放入工作内存的变量副本中
* 5.use：作用于工作内存的变量，他把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作
* 6.assign（赋值）：作用于工作内存的变量，他把一个从执行引擎接受到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
* 7.store：作用于工作内存的变量，他把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用
* 8.write：作用于主内存的变量，他把store操作从工作内存中得到的变量的值放入主内存的变量中。

### 对于long和double型变量的特殊规则
虚拟机对于64位的数据类型（long，double），允许将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load，store，read，write这四个操作的原子性，这就是所谓的long和double的非原子性协议。如果有多个线程共享一个并未声明为volatile的long或double类型的变量，而且同时对他们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了”半个变量“的数值


# 二、Java指令重排序
Java在实际执行程序的时候，为了提升性能，编译器和处理器经常会对Java指令进行重排序。

一般重排序分为三种：
* 1.编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
* 2.指令级并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应的机器指令的执行顺序。
* 3.内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储的操作看上去可能是在乱序执行的。

以上三种重排序方式，其中第一种是编译器重排序，第二、三种是处理器重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序。但是这些重排序的优化依然可能造成线程安全问题，比如DCL问题。
## DCL问题
DCL:double-check-locking,双重检查锁。这个双重检查锁最常见的应用就是在单例模式中：
```
public class Singleton {
    private static Singleton singleton;

    private Singleton() {
    }

    public static Singleton GetInstance() {
        //第一重check
        if (singleton == null) {
            synchronized (Singleton.class) {
                //第二重check
                if (singleton == null) {
                    singleton = new Singleton();   // 1
                }
            }
        }
        return singleton;  // 2
    }
}
```
而在代码执行过程中
```
singleton = new Singleton();   // 1
```
这一步实例化代码其实是分三步的：1.1申请对象空降。  1.2调用对象的构造方法初始化对象。 1.3将singleton指向对象。 而在这个过程中，Java底层会为了性能，对1.1、1.2、1.3、2这四步指令进行重排序，也就是说可能4会在1.2之前执行，那此时返回对还是为null。这就是DCL问题。

解决方式：
* 1.用volatile修饰singleton，阻止指令的重排序。
* 2.用饿汉式实现单例，不管会不会使用到该类，一开始就实例化该类的单例对象。

## happens-before规则
重排序底层的规则非常的复杂，因此JMM为程序员在上层提供了六条规则，这样我们就可以根据规则去推论跨线程的内存可见性问题，而不用再去理解底层重排序的规则。

happens-before规则定义：
* 1.如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
* 2.两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。只要保证重排序之后执行的结果与按happens-before关系来执行的结果一致即可。

#### happens-before规则中所指的操作可以分别在多个线程中。

具体规则：
* 1.程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
* 2.监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
* 3.volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
* 4.传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
* 5.start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
* 6.join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。
* 7.程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。
* 8.对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。

个人理解：这些规则并不能强制的在多线程的场景下完美执行。比如volatile变量规则，如果能完美执行，应该不会出现多个线程对共享变量累加与预期不符的问题。


# 三、运行时数据区域
## 程序计数器
较小的内存空间，当前线程所执行的字节码的行号指示器。每个线程都有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储在线程私有内存中。

## 虚拟机栈
线程私有。
生命周期与线程相同。
每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。方法的调用和执行对应这个栈帧的入栈和出栈。

该内存区域两种常见异常：
StackOverflowError:请求的栈的深度大于虚拟机允许的深度时就会抛出该异常
OutOfMemoryError:java虚拟机可以动态扩展的 情况下，如果扩展时无法申请到足够的内存，就会抛出该异常

## 本地方法栈
线程私有。与虚拟机栈作用相似，区别：虚拟机栈为执行java方法（字节码）服务，而本地方法栈为Native方法服务。也会出现以上两种异常。
* HotSpot中不区分本地方法栈和虚拟机栈。

## 堆
内存最大区域。被所有线程共享，虚拟机启动时创建。唯一的目的就是存放对象实例。 
java虚拟机规范上说所有的对象实例和数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，所有对象都分配在堆上也渐渐不是那么绝对了。
是垃圾收集器管理的主要区域。
垃圾收集基本采用分代收集算法，所以堆主要分新生代和老生代。
这部分内存空间可以物理不连续但是要逻辑连续。
动态扩展的情况下，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError的异常。

### 对象的访问定位
通过虚拟机栈上的引用类型来操作堆上的具体对象，目前主流的访问方式有直接指针和使用句柄两种方式（图片来源《深入理解Java虚拟机》）：
* 1.句柄访问：
<div align="center"> <img src="https://github.com/RJianPeng/Technology-Stack/blob/master/Java/photo/%E5%8F%A5%E6%9F%84.png"/></div><br>
优势：对象移动的时候只用改变实例数据指针，reference本身不改变

* 2.直接指针：
<div align="center"> <img src="https://github.com/RJianPeng/Technology-Stack/blob/master/Java/photo/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png"/></div><br>
优势：速度快，Sun HotSpot用的这种

### 对象的内存布局
对象的内存主要分为三块区域：
* 1.对象头：
* ①一部分用于存储对象自身的运行时数据
* ②另一部分是类型指针，即用来指向类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例（查找对象的元数据信息不一定要经过对象本身，这种结构对于对象的访问是采用的直接指针访问对象的方式，上面有讲）
* ③如果是数组，还有一块数据用于记录数组的长度，这个部分还有监视器锁（monitor）的信息

* 2.实例数据部分：
* 存储在程序代码中定义的各种类型的字段内容，这部分的存储内容的存储顺序受虚拟机分配策略和在代码中定义的顺序影响

* 3.对齐填充
* 起到占位符的作用

## 方法区
各个线程的共享区域。
存储被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
java虚拟机规范把方法区描述为堆的一个逻辑部分，也叫非堆，目的应该是与堆区分开来，可以粗略的理解为非堆包含了永久带，永久带又包括了方法区。           
* 这部分的垃圾回收目标主要是针对常量池的回收和对类型的卸载。 

无法满足内存分配需要时，抛出OutOfMemoryError异常。
### 运行时常量池
方法区的一部分。
存放在编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池存放。
每个class文件的常量池被加载之后就将引用存放在这个地方。

### 字符串常量池
和运行时常量池的概念不同。字符串常量池是全局共享的。存放的是String对象的引用，方便复用。
（关于字符串常量池部分的使用可以看https://github.com/RJianPeng/Technology-Stack/blob/master/Java/Java%E5%9F%BA%E7%A1%80.md#string ）

# 四、垃圾回收
## 判断对象是否需要回收的算法
### 引用计数算法
在对象中记录该对象被引用的个数，为0的时候说明这个对象没有存在的意义。
* 主流的java虚拟机都没有选用这个算法来管理内存，因为这个算法很难解决对象之间循环引用的问题。

### 可达性分析算法
主流应用中都是使用这个算法来进行判定。
从一系列的称为“GC Roots"的对象（
* (1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。
* (2). 方法区中的类静态属性引用的对象。
* (3). 方法区中常量引用的对象。
* (4). 本地方法栈中JNI(Native方法)引用的对象。

）作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则此对象是不可用的。

一个对象真正的死亡，至少要经历两次标记过程：如果对象在进行可达性分析时，发现没有与GC Roots相连接的引用链，那么他将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize（）方法或者已经执行过finalize()方法时，都认为这个对象没有必要执行finalize()方法。没有必要执行的直接被回收了，有必要执行的，会被放到一个叫做F-Queue的队列中，并由虚拟机建立的，低优先级的Finalizer线程去执行他。finalize（）是对象逃脱死亡的最后一次机会。

## 引用
上述两种算法都与引用相关，什么是引用，java中的定义是：如果reference类型的数据中存储的数值代表的是另一块内存的起始位置，就称这块内存代表着一个引用。
引用分为四种：强引用，软引用，弱引用，虚引用，四种引用强度依次降低
### 1.强引用：
类似 Object o=new Object();这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。即通过new实例化的对象不会被回收，除非这个对象所在方法结束，此时对这个对象的存在于虚拟机栈中的引用被清空，此时这个对象会被回收。

### 2.软引用：
描述一些还有用但并非必须的对象。对于这些对象，在系统将要发生内存溢出异常之前，将会把这些对象放进回收范围内进行二次回收。通过SoftReference类来实现软引用。
```
Object obj = new Object();
SoftReference<Object> sf  = new SoftReference<Object>(obj);//创建软引用对象
```

### 3.弱引用：
描述非必须对象，强度比软引用弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。
```
Object obj = new Object （）；
WeakReference<Object> wf = new WeakReference<Object>（）；//创建弱引用对象
```
    
### 4.虚引用：
最弱的引用，该引用对对象的生存时间没有影响，只要垃圾回收开始工作，就会被回收
```
Object obj = new Object （）；
PhantomReference<Object> pf = new PhantomReference<Object>(obj)；//创建虚引用对象
```

## 方法区的回收
主要回收：废弃常量和无用的类

废弃常量：没有任何变量引用了这个常量

无用的类：
* 1.该类的所有实例都已经被回收
* 2.加载该类的ClassLoader已经被回收
* 3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法      

## 垃圾回收算法
### 标记清除算法
标记清除算法：算法分标记和清除两个阶段。标记：标记出所有需要回收的对象。清除：统一回收所有被标记的对象。

不足：
* 效率问题，标记和清除两个过程的效率都不高。
* 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

### 复制算法
将可用内存按容量划分为大小相等的两块，每次只是用其中的一块。这一块的内存用完了，就将还存活的对象复制到另一块上，然后清理这一块的空间。在现在的应用中，将内存分为了一块较大的Eden空间和两块较小的Survivor空间每次使用其中一块Survivor和Eden空间Eden和Survivor空间比例是8：1。复制算法在对象存活率较高时就需要进行较多的赋值操作，效率会变低，而且如果不浪费50%的空间，就需要额外的空间进行分配担保，所以老年代中一般不能直接选用这种算法。

复制算法的空间分配担保：JVM继续检查老年代最大的可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则正常进行一次Young GC，尽管有风险（因为判断的是平均大小，有可能这次的晋升对象比平均值大很多）；如果小于，或者HandlePromotionFailure设置不允许空间分配担保，这时要进行一次Full GC。

### 标记整理算法
标记整理算法不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后清理掉其他的内存。

### 分代收集算法
根据对象存活周期的不同将内存划分为几块。一般是把堆分为新生代和老年代。对象存活率高的时候（老年代）用标记清除或者标记整理算法。对象存活率低的时候（新生代）用复制算法。


## 垃圾收集器
是内存回收的具体实现
### Serial收集器
最基本，发展历史最悠久的收集器。是个单线程的收集器，在进行垃圾收集时，必须暂停其他所有的工作线程，直到收集结束。是虚拟机运行在Client模式下的默认新生代收集器。优点：简单而高效，对于限定单个CPU的环境来说，没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。

### ParNew收集器
Serial收集器的多线程版本（在垃圾收集器中，并发指的是用户线程与垃圾收集线程并行工作，并行指的是多条垃圾收集线程并行工作，用户线程仍然处于等待状态。）

### Parrallel Scavenge收集器
新生代收集器，复制算法，并行的多线程收集器。
特点：这个收集器的目标是达到一个可控制的吞吐量。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。

### Serial Old收集器
Serial老年代版本，标记整理算法

### CMS（Concurrent Mark Sweep)收集器
以获得最短回收停顿时间为目标的收集器。老年代垃圾收集器标记清除算法。

总共有四个步骤：
* 1.初始标记：标记GC Roots能直接关联到的对象，速度很快。
* 2.并发标记：GC Roots Tracing的过程
* 3.重新标记：修正并发标记期间的变动
* 4.并发清除
* 缺点：1.对CPU资源非常敏感，受CPU的影响非常大  2.无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。因为在垃圾清除阶段用户进程还在运行，可能会产生新的垃圾，所以CMS收集器需要预留一部分空间给并发清理时的用户进程使用   3.标记清除算法，会产生内存碎片。
![CMS垃圾清除过程](https://github.com/RJianPeng/Technology-Stack/blob/master/Java/photo/CMS%E5%9E%83%E5%9C%BE%E6%B8%85%E9%99%A4.png)


### G1收集器
特点：
* 1.并发与并行
* 2.分代收集
* 3.空间整合：从整体来看是标记整理算法，从局部来看是基于“复制”算法实现的，都保证了G1收集器不会产生空间碎片
* 4.可预测的停顿

将整个java堆划分为多个大小相等的独立区域（Region），依然保留新生代老年代的概念，但他们之间不再是物理隔离的了。G1跟踪各个Region里面的垃圾堆积的价值大小，建立一个优先列表，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。
某种程度上优化了STW（stop the world）问题
收集步骤：
1.初始标记
2.并发标记
3.最终标记
4.筛选回收


## 对象内存分配策略
* 1.大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时虚拟机将执行一次Minor GC
（Minor GC：在新生代中发生的垃圾收集动作。Major GC：在老年代中发生的垃圾收集动作。FullGC：清理整个堆空间，包括新生代和老年代）
* 2.大对象直接进入老年代。大对象就是指需要大量连续存储空间的对象，最典型的大对象就是那种很长的字符串以及数组。
* 3.长期存活的对象将进入老年代。虚拟机给每个对象定义了一个对象年龄计数器。对象到Survivor区的初始年龄为1，每熬过一次MinorGC，年龄就增加1岁，增加到一定程度，就会被晋升到老年代中
* 4.动态对象年龄判定。如果在Survivor空间中，相同年龄所有对象大小综合大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。
* 5.空间分配担保。只要老年代的连续空间大于新生代的对象总大小或者历次晋升的平均大小，就能直接进行MinorGC，否则就先进行FullGC。

### Full GC 和Minor GC的触发条件：
#### Minor GC
Eden区域满了就会触发

#### Full GC:
* 1. 调用 System.gc()
只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。
* 2. 老年代空间不足
老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。
为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。
* 3. 空间分配担保失败
使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。
* 4. Concurrent Mode Failure
执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC

# 五、虚拟机类加载机制
类的整个生命周期：加载，验证，准备，解析，初始化，使用，卸载

其中，验证，准备，解析三个部分统称为连接。 加载，验证，准备，初始化，卸载这五个阶段的顺序是确定的，而解析阶段则不一定：它在某些情况下可以再初始化阶段之后再开始，这是为了支持java语言的运行时绑定。此外，类加载的这些阶段通常都是互相交叉的混合式进行的。

必须立即对类进行初始化的五种情况：
* 1. 遇到new,getstatic,putstatic,invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。
* 2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
* 3. 当初始化一个类的时候，如果发现其父类没有进行过初始化，则需要先触发其父类的初始化（但如果是接口，并不要求其父接口必须完成初始化，只有真正用到父接口的时候才会进行初始化）
* 4. 虚拟机启动的时候，用户要制定一个执行的主类，虚拟机会先初始化这个主类
* 5. 如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic，REF_putStatic,REF_invokeStatic的方法句柄，而且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化

## 加载
加载阶段虚拟机完成的三个事情：
* 1.通过一个类的全限定名来获取定义此类的二进制字节流
* 2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
* 3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确的说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。但数组类不同，数组类本身不是通过类加载器创建，是由java虚拟机直接创建的，但数组类的元素类型还是要靠类加载器去创建。


## 验证
是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。

四个检验动作：文件格式验证，元数据验证，字节码验证，符号引用验证
* 1.文件格式验证：验证字节流是否符合Class文件格式规范，并且能被当前版本的虚拟机处理。
例：是否以魔数0XCAFEBABE开头（cafe baby)
这个阶段主要目的是保证输入的字节流能正确解析并存储于方法区内，格式上符合描述一个java类型信息的要求。后面三个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。
* 2.元数据验证：是对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求。
* 3.字节码验证：通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件
* 4.符号引用验证：这个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。

## 准备
是正式为类变量分配内存并设置类变量初始值的阶段，这些类变量所使用的内存都将在方法区中进行分配。
这里说的初始值“通常情况”下是数据类型的零值，因为这个时候还没有执行任何java方法（包括构造函数）。相对的会有一些“特殊情况”，如果存在ConstantValue属性，那么就会被初始化为Constant Value指定的值，比如：
public static final int value=123;

## 解析
虚拟机将常量池内的符号引用替换为直接引用的过程。
* 符号引用：以一组符号来描述所引用到的目标，符号只要使用时能定位到目标即可。符号引用和虚拟机实现的内存布局无关，引用的目标比一定已经加载到内存中。
* 直接引用：可以是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存布局相关的。如果有了直接引用，那引用的目标必定在内存中存在。

## 类加载器：
能实现“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作的代码模块。
比较两个类是否相等（==），首先是要看两个类是否是同一个类加载器加载的。

## 双亲委派模型：
类加载器分两种：
* 1.启动类加载器：使用C++语言来实现，是虚拟机自身的一部分
* 2.其他所有的类加载器：有java语言实现，独立于虚拟机外部，全部继承于java.lang.ClassLoader

在开发中主要的3种系统提供的类加载器：
* 1.启动类加载器：使用C++进行实现，是虚拟机自身的一部分。负责将JRE_HOME/lib中的类库加载到虚拟机内存中
* 2.扩展类加载器：负责将JAVA_HOME/lib/ext中的类库加载到虚拟机内存中
* 3.应用程序类加载器：一般又称为系统类加载器，负责加载用户类路径上指定的类库

### 双亲委派模型
要求除了启动类加载器之外，其他类加载器应当都有自己的父类加载器。这里的父子关系是使用组合的关系。如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求为派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当附加在其反馈自己无法完成这个加载请求的时候，子加载器才会尝试自己去加载。

### 为什么要使用双亲委派模型
java类随着其类加载器一起具备了一种带优先级的层次关系。如果没有双亲委派模型，那么假如用户定义了一个成为java.lang.Object的类，并放在classpath中，那么系统会出现多个object对象，则java类型体系中最基础的行为都无法保证。


# 六、Java内存泄漏
java内存泄露：程序在申请内存之后，没有及时的释放内存。

根本原因：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露

内存泄露的情况：
* 1、静态集合类引起内存泄露： 
像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。
* 2、当集合里面的对象属性被修改后，再调用remove（）方法时不起作用。
* 3、监听器 
在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。
* 4、各种连接 
比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。










