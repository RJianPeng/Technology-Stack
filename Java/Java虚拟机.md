* [一、Java内存模型](#一java内存模型)
* [二、Java指令重排序](#二java指令重排序)


# 一、Java内存模型
Java内存模型（JMM)：

为了缩小CPU运算速度和主存读写速度的差异，每个工作线程都会有自己的工作内存。所有变量储存在主内存中，每条线程还有自己的工作内存，里面保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都是在工作内存中完成的，完成之后再将新的变量的值写回主内存，并且Java内存模型还决定了一个线程写入主内存的共享变量什么时候对其他线程是可见的。

另外JMM也是用来屏蔽各种硬件和操作系统的内存访问差异，以实现让java程序在各个平台下都能达到一致的内存访问效果。是Java多线程共享内存的抽象模型。多个线程之间通过共享内存实现线程通信。

内存模型如图（图片来源：https://www.jianshu.com/p/15106e9c4bf3）：
<div align="center"> <img src="https://upload-images.jianshu.io/upload_images/4899162-66736384361f6b8b.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp"/></div><br>

### java内存模型关于主内存和工作内存的交互协议，定义了8种操作来完成：
* 1.lock：作用于主内存的变量，他把一个变量标识为一条线程独占的状态
* 2.unlock：作用于主内存的变量，他把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
* 3.read：作用于主内存的变量，他把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
* 4.load：作用于工作内存的变量，他把read操作从主内存中得到的变量值放入工作内存的变量副本中
* 5.use：作用于工作内存的变量，他把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作
* 6.assign（赋值）：作用于工作内存的变量，他把一个从执行引擎接受到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
* 7.store：作用于工作内存的变量，他把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用
* 8.write：作用于主内存的变量，他把store操作从工作内存中得到的变量的值放入主内存的变量中。

# 二、Java指令重排序
Java在实际执行程序的时候，为了提升性能，编译器和处理器经常会对Java指令进行重排序。

一般重排序分为三种：
* 1.编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
* 2.指令级并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应的机器指令的执行顺序。
* 3.内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储的操作看上去可能是在乱序执行的。

以上三种重排序方式，其中第一种是编译器重排序，第二、三种是处理器重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序。但是这些重排序的优化依然可能造成线程安全问题，比如DCL问题。
## DCL问题
DCL:double-check-locking,双重检查锁。这个双重检查锁最常见的应用就是在单例模式中：
```
public class Singleton {
    private static Singleton singleton;

    private Singleton() {
    }

    public static Singleton GetInstance() {
        //第一重check
        if (singleton == null) {
            synchronized (Singleton.class) {
                //第二重check
                if (singleton == null) {
                    singleton = new Singleton();   // 1
                }
            }
        }
        return singleton;  // 2
    }
}
```
而在代码执行过程中
```
singleton = new Singleton();   // 1
```
这一步实例化代码其实是分三步的：1.1申请对象空降。  1.2调用对象的构造方法初始化对象。 1.3将singleton指向对象。 而在这个过程中，Java底层会为了性能，对1.1、1.2、1.3、2这四步指令进行重排序，也就是说可能4会在1.2之前执行，那此时返回对还是为null。这就是DCL问题。

解决方式：
* 1.用volatile修饰singleton，阻止指令的重排序。
* 2.用饿汉式实现单例，不管会不会使用到该类，一开始就实例化该类的单例对象。
