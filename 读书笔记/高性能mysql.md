- [第一章 Mysql架构和历史](#第一章mysql架构和历史)
- [第四章](#第四章)
- [第五章 创建高性能的索引](#第五章创建高性能的索引)


# 第一章 Mysql架构和历史


# 第五章 创建高性能的索引
## 5.1 索引基础

mysql只能高效的使用索引的最左前缀列


在mysql中，索引是在引擎层而不是服务器层实现的

Innodb中，主键索引为一级索引，其他索引为二级索引
Myisam中主键索引和其他索引差不多，没有一级二级之分

哈希索引不是按照索引值顺序进行存储的，所以也就无法用于排序。
哈希索引也不支持根据部分索引列进行查找，因为哈希值是根据所有的索引列算出来的。
哈希索引只支持等值查找

InnoDB有‘自适应哈希索引’的特殊功能，可以对热点数据自动进行哈希索引，对用户透明

索引队列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。
eg:select * from table_eg where id + 1 = 5;

前缀索引：可以用于对blog、text或者很长的varchar进行索引

## 5.2 索引的优点
三星索引系统：
* 1.索引将相关的记录放到一起为一星
* 2.索引中的数据顺序和查找中的排序顺序一致为二星
* 3.索引中包含了查询需要的所有列为三星

### 5.3.3 多列索引
mysql5.0以及之后的版本中，如果遇到查询的条件包含多个单独的索引而没有一个大的索引时，会采用多个单独的索引进行查询的合并
```
eg:
select * from table_test where id = 1 or test_id = 1;

//5.0之前的版本对于这种查询会使用全表扫描

//5.0及之后的版本会进行这种操作
select * from table_test where id = 1
union 
select * from table_test where test_id = 1

//是否采用了这种优化可以在explain的extra字段里看到（union/intersection字段）
```
这种优化方式说明了表上的索引与具体使用并不匹配，需要考虑进一步优化索引。

当发起一个对覆盖索引的查询时，explain的extra字段会看到Using Index字段
（覆盖索引：查询的列在索引列中，这个时候使用二级索引可以满足查询需求，不需要再通过一级索引进行查询）

### 5.4.1 支持多种过滤条件
最左前缀索引匹配遇到范围查询就会停止匹配，所以这种时候尽可能把范围查找的字段放在索引的后面，以便优化器能够使用尽可能多的索引列。

范围查询：即select * from a where a.id > xxx 类似于这种场景，而select * from a where a.id in(xxx,xxx)这种场景，
则为多个等值条件查询，不会导致最左前缀索引匹配停止。

分页查询，页数过多的时候可能导致性能变差，可以根据二级索引覆盖主键的特性，现根据二级索引分页取出主键，然后根据主键聚簇索引的特性快速取到需要的分页数据
```
select * from test_table join (select id from test_table where a= ‘test’ order by b limit 1000,10) as x using id
```

## explain结果集s
### type字段
* 1.index：说明用了索引扫描做排序



### extra字段
* 1.Using Index：说明发起了一个对覆盖索引的查询
* 2.Using Where：说明执行引擎返回给mysql服务器之后，在服务器层次还做了where的筛选

