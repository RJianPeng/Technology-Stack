* [面向对象的基本原则](#面向对象的基本原则)


## 面向对象的基本原则
* 单一职责原则SRP：类的功能要单一
* 开放-封闭原则OCP:一个模块在扩展性方面应该是开放的，而在更改性方面应该是封闭的
* 依赖倒转原则DIP:抽象不应该依赖细节，细节应该依赖于抽象。即我们应该要针对接口编程而不是针对实现编程。
* 接口隔离原则ISP:模块间要通过接口实现耦合而不是通过具体的类
* 里氏替换原则LSP:子类应该可以替换父类出现在父类能够出现的地方

## 单例模式

## 原型模式
通用逻辑封装到clone方法中，外部调用简单明了。
需要实现Cloneable接口，深浅拷贝是个点。
应用场景较少

## 适配器模式
通过反射，接口实现对不同的格式进行统一 用通用的逻辑来进行处理

## 桥接模式
在组合场景下，分别定义各个模块的内容，避免创建笛卡尔积个对象
eg： 
inter A        inter B

class A1       class B1

class A2       class B2

而不是创建

classA1B1   classA1B2  classA2B1   classA2B2

## 组合模式
组合模式中的重要概念：决策树
决策树主要包含树节点和节点之间的连线，节点主要包含对所属连线的引用和节点值以及其下连线的判定变量 ，连线包含了当前参数是否能达到连线
另一端的节点的判定，一个节点可以包含多个所属连线

## 装饰器模式
三个核心处理部分：1.继承了处理接口  2.提供了构造函数   3.覆盖了处理方法
装饰器模式也是类似于组合的形式，可以在子类过多的时候使用，根据使用场景临时进行组合，避免子类过多不好管理。

## 门面模式
将通用的逻辑封装成简单方法使用，降低使用难度和可复用性

## 享元模式
共享元素可以理解为，核心是将通用的，变化不频繁或对于变化更新及时性不敏感的部分，进行缓存，多次复用

## 代理模式
通过Java的代理机制，让复杂的服务变为轻量级调用，让代码更加整洁干净易于维护。常见于中间件场景，通过注解+AOP的方式，对中间件的复杂调用进行代理，实现简单使用。

# 行为模式

## 责任链模式
核心是解决一组服务中先后执行处理关系。